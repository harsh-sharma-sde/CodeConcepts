---
title: Question 24 (DSA)
description: Learn how to flatten deeply nested objects or arrays in JavaScript for easier manipulation and processing
order: 96
---

Flattening a deeply nested structure usually refers to two different tasks depending on the data type:
1.  **Arrays:** Converting a multi-dimensional array into a single-dimensional list of values.
2.  **Objects:** Converting a nested tree into a single-depth object with concatenated keys (e.g., `user.address.city`).

Below are the most efficient ways to handle both in **JavaScript** and **Python**, including robust solutions for circular references.

---

### 1. Flattening Arrays (Deep)

#### **JavaScript**
Modern JavaScript has a built-in `.flat()` method, but it requires a depth. For a truly "deep" flatten without knowing the depth:

```javascript
// Recursive approach
function flattenArray(arr) {
  return arr.reduce((acc, val) => 
    Array.isArray(val) ? acc.concat(flattenArray(val)) : acc.concat(val), 
  []);
}

// Example
const nested = [1, [2, [3, [4]], 5]];
console.log(flattenArray(nested)); // [1, 2, 3, 4, 5]
```

#### **Python**
Python doesn't have a built-in deep flatten for lists, so a generator is the most memory-efficient approach.

```python
def flatten_list(nested_list):
    for item in nested_list:
        if isinstance(item, list):
            yield from flatten_list(item)
        else:
            yield item

# Example
nested = [1, [2, [3, [4]], 5]]
print(list(flatten_list(nested))) # [1, 2, 3, 4, 5]
```

---

### 2. Flattening Objects (Deep)

This converts `{a: {b: 1}}` into `{"a.b": 1}`.

#### **JavaScript (Robust Recursive)**
This version handles custom separators and avoids overwriting values.

```javascript
function flattenObject(obj, prefix = '', res = {}) {
  for (let key in obj) {
    const propName = prefix ? `${prefix}.${key}` : key;
    if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {
      flattenObject(obj[key], propName, res);
    } else {
      res[propName] = obj[key];
    }
  }
  return res;
}

// Example
const nestedObj = { a: 1, b: { c: 2, d: { e: 3 } } };
console.log(flattenObject(nestedObj)); 
// Output: { "a": 1, "b.c": 2, "b.d.e": 3 }
```

#### **Python (Robust Recursive)**
Using a dictionary comprehension or a simple loop:

```python
def flatten_dict(d, parent_key='', sep='.'):
    items = []
    for k, v in d.items():
        new_key = f"{parent_key}{sep}{k}" if parent_key else k
        if isinstance(v, dict):
            items.extend(flatten_dict(v, new_key, sep=sep).items())
        else:
            items.append((new_key, v))
    return dict(items)

# Example
nested_dict = {'a': 1, 'b': {'c': 2, 'd': {'e': 3}}}
print(flatten_dict(nested_dict))
# Output: {'a': 1, 'b.c': 2, 'b.d.e': 3}
```

---

### 3. Handling Edge Cases

#### **Circular References**
If an object references itself (e.g., `obj.self = obj`), a standard recursive function will cause a **Stack Overflow**. To fix this, track "seen" objects.

**JavaScript Example:**
```javascript
function safeFlatten(obj, prefix = '', res = {}, seen = new WeakSet()) {
  if (obj && typeof obj === 'object') {
    if (seen.has(obj)) return res; // Skip circular reference
    seen.add(obj);
  }
  // ... rest of the flattening logic ...
}
```

#### **Extremely Deep Structures (Iterative)**
If your data is thousands of levels deep, recursion might hit the call stack limit. Use a **Stack** (iterative) instead.

**JavaScript Iterative Object Flatten:**
```javascript
function iterativeFlatten(obj) {
  const res = {};
  const stack = [{ ptr: obj, prefix: '' }];

  while (stack.length) {
    const { ptr, prefix } = stack.pop();
    for (const key in ptr) {
      const propName = prefix ? `${prefix}.${key}` : key;
      if (typeof ptr[key] === 'object' && ptr[key] !== null) {
        stack.push({ ptr: ptr[key], prefix: propName });
      } else {
        res[propName] = ptr[key];
      }
    }
  }
  return res;
}
```

### Summary Recommendation
*   **For Arrays:** Use `arr.flat(Infinity)` in JS or a `yield from` generator in Python.
*   **For Objects:** Use the **Recursive** method for most cases. It is more readable and handles the majority of JSON-like data. 
*   **For Production APIs:** Always implement a **depth limit** or **circular check** if the data source is untrusted.