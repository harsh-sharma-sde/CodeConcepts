---
title: JavaScript Polyfills for ES6 Features
description: Learn how to implement polyfills for ES6 features like Promise, Map, and Array.prototype.filter for backward compatibility
order: 7
---

As an SDE 2, you know that a **Polyfill** is a piece of code used to provide modern functionality on older browsers that do not natively support it. 

Implementing these manually is a classic way to demonstrate knowledge of **Prototypes**, **this-binding**, and **Asynchronous state machines**.

---

### 1. Array.prototype.filter
**The SDE 2 View:** `filter` is a higher-order function. A robust polyfill must handle:
1.  **Sparse Arrays:** It should skip "holes" (indices that were never defined).
2.  **thisArg:** The second optional argument to set the `this` context for the callback.
3.  **Prototype Safety:** Ensuring we don't break existing behavior.

**Mechanics:** We attach the function to `Array.prototype`. Inside the function, `this` refers to the array instance.

```javascript
if (!Array.prototype.myFilter) {
    Array.prototype.myFilter = function(callback, thisArg) {
        // 'this' is the array instance
        const result = [];
        
        for (let i = 0; i < this.length; i++) {
            // Check if the index actually exists (handles sparse arrays)
            if (i in this) {
                // Execute callback with provided thisArg
                if (callback.call(thisArg, this[i], i, this)) {
                    result.push(this[i]);
                }
            }
        }
        return result;
    };
}

// Usage
const numbers = [1, 2, , 4]; // Note the hole at index 2
console.log(numbers.myFilter(x => x > 1)); // [2, 4]
```

---

### 2. Map (Data Structure)
**The SDE 2 View:** The core difference between a plain `Object` and a `Map` is that a Map allows **any value (objects, functions) as keys**. 

**Mechanics:** In a real engine, Maps are implemented using hash tables for $O(1)$ lookup. In a polyfill (where we can't access memory addresses), we typically maintain two internal arrays: one for keys and one for values. This makes lookup $O(n)$, but it maintains the "any type as key" contract.

```javascript
class MyMap {
    constructor() {
        this._keys = [];
        this._values = [];
    }

    set(key, value) {
        const index = this._keys.indexOf(key);
        if (index > -1) {
            this._values[index] = value;
        } else {
            this._keys.push(key);
            this._values.push(value);
        }
        return this;
    }

    get(key) {
        const index = this._keys.indexOf(key);
        return index > -1 ? this._values[index] : undefined;
    }

    has(key) {
        return this._keys.indexOf(key) > -1;
    }
}

// Usage: Object as a key
const objKey = { id: 1 };
const m = new MyMap();
m.set(objKey, "SDE 2 Data");
console.log(m.get(objKey)); // "SDE 2 Data"
```

---

### 3. Promise (Core Logic)
**The SDE 2 View:** A Promise is a **State Machine** with three states: `PENDING`, `FULFILLED`, and `REJECTED`. 

**Mechanics:** 
1.  **Immutability:** Once a promise is fulfilled/rejected, the state and value cannot change.
2.  **Async Execution:** The `.then()` callbacks must be executed asynchronously (to simulate the Microtask queue). We use `setTimeout` or `queueMicrotask` to ensure the callback runs after the synchronous code.

```javascript
class MyPromise {
    constructor(executor) {
        this.state = 'PENDING';
        this.value = undefined;
        this.handlers = []; // Queue of .then() callbacks

        const resolve = (value) => {
            if (this.state !== 'PENDING') return;
            this.state = 'FULFILLED';
            this.value = value;
            this.handlers.forEach(h => h.onFulfilled(value));
        };

        const reject = (error) => {
            if (this.state !== 'PENDING') return;
            this.state = 'REJECTED';
            this.value = error;
            this.handlers.forEach(h => h.onRejected(error));
        };

        try {
            executor(resolve, reject);
        } catch (e) {
            reject(e);
        }
    }

    then(onFulfilled, onRejected) {
        // For SDE 2 simplicity: Return a new Promise (Chaining)
        return new MyPromise((resolve, reject) => {
            const handle = () => {
                // Use setTimeout to move execution to the next tick 
                // (Simulating Microtask behavior)
                setTimeout(() => {
                    try {
                        if (this.state === 'FULFILLED') {
                            const result = onFulfilled(this.value);
                            resolve(result);
                        } else {
                            const result = onRejected(this.value);
                            resolve(result);
                        }
                    } catch (e) {
                        reject(e);
                    }
                }, 0);
            };

            if (this.state === 'PENDING') {
                this.handlers.push({ onFulfilled: handle, onRejected: handle });
            } else {
                handle();
            }
        });
    }
}

// Usage
new MyPromise((res) => res("Done!"))
    .then(val => console.log(val));
```

---

### Why this matters for SDE 2s:

1.  **Handling "Thenables":** SDE 2s know that `Promise.resolve` should check if the value is "thenable" (an object with a `.then` method) and flatten it.
2.  **Garbage Collection:** In the `Map` polyfill above, keeping objects in the `_keys` array prevents them from being garbage collected. This is why JS eventually added `WeakMap`â€”which doesn't hold strong references to keys.
3.  **Prototype Pollution:** When writing polyfills, SDE 2s use `Object.defineProperty` with `enumerable: false` to ensure that adding `filter` doesn't break `for...in` loops in existing legacy code.

```javascript
// The Professional way to polyfill
Object.defineProperty(Array.prototype, 'myFilter', {
    value: function() { /* implementation */ },
    enumerable: false, // Important!
    writable: true,
    configurable: true
});
```